//! Block Payload Building Context
//!
//! Types in this module are responsible for building one single version of a payload
//! at a time with a known parent block hash and access to the state of the chain.

use super::block::{BlockContext, EvmInstance, PayloadState};
use crate::traits::ClientBounds;
use alloy_consensus::{
    constants::EMPTY_WITHDRAWALS, proofs, Block, BlockBody, Eip658Value, Header, Receipt,
    EMPTY_OMMER_ROOT_HASH,
};
use alloy_eips::{eip7685::EMPTY_REQUESTS_HASH, merge::BEACON_NONCE, Typed2718};
use alloy_op_evm::block::receipt_builder::OpReceiptBuilder;
use alloy_primitives::{Address, U256};
use op_alloy_consensus::{OpDepositReceipt, OpTxEnvelope};
use op_revm::OpHaltReason;
use reth_chain_state::{ExecutedBlock, ExecutedBlockWithTrieUpdates};
use reth_evm::{eth::receipt_builder::ReceiptBuilderCtx, ConfigureEvm, Evm};
use reth_node_api::{Block as _, PayloadBuilderError};
use reth_optimism_consensus::{calculate_receipt_root_no_memo_optimism, isthmus};
use reth_optimism_node::OpBuiltPayload;
use reth_optimism_payload_builder::error::OpPayloadBuilderError;
use reth_optimism_primitives::{OpPrimitives, OpReceipt, OpTransactionSigned};
use reth_primitives::{Recovered, RecoveredBlock};
use reth_primitives_traits::{SignedTransaction, SignerRecoverable};
use reth_provider::ExecutionOutcome;
use reth_revm::db::states::bundle_state::BundleRetention;
use revm::{
    context::{result::ResultAndState, ContextTr},
    DatabaseCommit,
};
use std::sync::Arc;
use tracing::warn;

/// An instance of this type is instantiated when building a new block payload version.
/// There may be multiple instances of this type created for one parent block. Each instance
/// represents a different payload building attempt.
///
/// An instance of this type comes with a preconfigured EVM and State mounted at the
/// parent block hash.
pub struct PayloadBuilderContext<Client: ClientBounds> {
    /// Access to the block context that is common to all payloads built on top of the same parent block.
    block_ctx: Arc<BlockContext<Client>>,

    /// Transactions that are included in the payload being built.
    transactions: Vec<OpTransactionSigned>,

    /// Transaction receipts that are generated by the transactions included in the payload.
    receipts: Vec<OpReceipt>,

    /// An EVM instance that is preconfigured with the parent block state and ready to execute
    /// transactions in the context of the payload being built.
    evm: EvmInstance,

    /// Tracks total fees accumulated by the transactions included in the payload.
    total_fees: U256,

    /// The total gas used by the transactions included in the payload.
    gas_used: u64,

    /// The total data availability size used by the transactions included in the payload.
    da_bytes_used: u64,
}

impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// Creates a new payload builder with its state initialized and ready to add user
    /// transactions to it. As part of the initialization all sequencer mandated transactions
    /// are executed and their state changes are applied.
    pub fn new(block_ctx: Arc<BlockContext<Client>>) -> Result<Self, PayloadBuilderError> {
        let evm = block_ctx.create_evm()?;

        let mut instance = Self {
            evm,
            block_ctx,
            transactions: vec![],
            receipts: vec![],
            total_fees: Default::default(),
            gas_used: Default::default(),
            da_bytes_used: Default::default(),
        };

        // Get the mandatory seequencer transactions from the Payload Attributes
        // sent by the CL during FCU.
        let sequencer_txs: Vec<_> = instance
            .block_ctx
            .sequencer_transactions()
            .cloned()
            .collect();

        for tx in sequencer_txs {
            // in include all mandatory sequencer transactions at the top of the payload.
            instance.insert(tx.value().try_clone_into_recovered().map_err(|_| {
                PayloadBuilderError::other(OpPayloadBuilderError::TransactionEcRecoverFailed)
            })?)?;
        }

        Ok(instance)
    }
}

// Transaction simulation and inclusion methods for the payload builder context.
impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// Simulates a transaction in the context of the currently aggregated state of the
    /// this payload without committing it.
    ///
    /// This can be used to implement various filters and checks such as revert protection,
    /// builder payments, gas usage, etc.
    pub fn simulate(
        &mut self,
        transaction: &Recovered<OpTxEnvelope>,
    ) -> Result<ResultAndState<OpHaltReason>, PayloadBuilderError> {
        // A sequencer's block should never contain blob transactions.
        if transaction.is_eip4844() {
            return Err(PayloadBuilderError::other(
                OpPayloadBuilderError::BlobTransactionRejected,
            ));
        }

        self.evm
            .transact(transaction)
            .map_err(PayloadBuilderError::other)
    }

    /// Adds a transaction to the payload being built and commits to its state.
    /// Any state changes caused by this transaction will affect the next simulated or
    /// included transaction.
    pub fn insert(
        &mut self,
        transaction: Recovered<OpTxEnvelope>,
    ) -> Result<(), PayloadBuilderError> {
        let simulation = self.simulate(&transaction)?;
        self.insert_presimulated_unchecked(transaction, simulation)
    }

    /// Adds a presimulated transaction to the payload being built and commits to its state
    /// changes. This method will not execute the transaction, instead it assumes that
    /// the transaction has been already correctly simulated on the latest state.
    ///
    /// It is up to the caller to ensure that no other transaction was inserted into the
    /// payload between the transactiop simulation and this call.
    pub fn insert_presimulated_unchecked(
        &mut self,
        transaction: Recovered<OpTxEnvelope>,
        simulation: ResultAndState<OpHaltReason>,
    ) -> Result<(), PayloadBuilderError> {
        let ResultAndState { result, state } = simulation;

        // accumulate used gas and fees regardless of the result
        self.gas_used += result.gas_used();

        // build a receipt for the transaction
        let receipt_builder = self
            .block_ctx
            .evm_config()
            .block_executor_factory()
            .receipt_builder();

        let receipt = match receipt_builder.build_receipt(ReceiptBuilderCtx {
            tx: transaction.inner(),
            evm: &self.evm,
            result,
            state: &state,
            cumulative_gas_used: self.gas_used,
        }) {
            // this path is taken when the transaction is a regular transaction
            Ok(receipt) => receipt,

            // this path is taken when the transaction is a deposit
            Err(receipt_ctx) => {
                let receipt = Receipt {
                    status: Eip658Value::Eip658(receipt_ctx.result.is_success()),
                    cumulative_gas_used: receipt_ctx.cumulative_gas_used,
                    logs: receipt_ctx.result.into_logs(),
                };

                // stop holding a ref on the EVM
                // w're going to ref it mutably in a bit
                let _ = receipt_ctx.evm;

                let deposit_nonce = if self.block_ctx().is_regolith_active() {
                    Some(
                        self.evm
                            .db()
                            .load_cache_account(transaction.signer())
                            .map(|account| account.account_info().unwrap_or_default().nonce)
                            .map_err(|_| {
                                PayloadBuilderError::other(
                                    OpPayloadBuilderError::AccountLoadFailed(transaction.signer()),
                                )
                            })?,
                    )
                } else {
                    // Note that this *only* needs to be done post-regolith hardfork, as deposit nonces
                    // were not introduced in Bedrock.
                    None
                };
                receipt_builder.build_deposit_receipt(OpDepositReceipt {
                    inner: receipt,
                    deposit_nonce,
                    // The deposit receipt version was introduced in Canyon to indicate an
                    // update to how receipt hashes should be computed when set.
                    // The state transition process ensures this is only set for post-Canyon
                    // deposit transactions.
                    deposit_receipt_version: self.block_ctx().is_canyon_active().then_some(1),
                })
            }
        };

        self.receipts.push(receipt);

        // store state changes of this transaction
        self.state().commit(state);

        // add the transaction to the list of transactions included in the payload
        self.transactions.push(transaction.into_inner());

        // we're done. At this point the state of the payload has been updated
        // to reflect the execution of the transaction.
        Ok(())
    }
}

// private methods for the payload builder context.
impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// the context of the block that this payload is being built on top of.
    fn block_ctx(&self) -> &BlockContext<Client> {
        &self.block_ctx
    }

    /// Returns the list of all transaction senders (signers) that are included in the
    /// payload being built in the same order as the transactions themselves.
    fn senders(&self) -> Result<Vec<Address>, PayloadBuilderError> {
        self.transactions
            .iter()
            .map(|tx| tx.recover_signer())
            .collect::<Result<Vec<_>, _>>()
            .map_err(PayloadBuilderError::other)
    }

    /// Returns the state of the evm that is used to build the payload.
    /// This state accumulates all changes made by transactions included in the payload.
    fn state(&mut self) -> &mut PayloadState {
        self.evm.db_mut()
    }
}

impl<Client: ClientBounds> TryFrom<PayloadBuilderContext<Client>> for OpBuiltPayload {
    type Error = PayloadBuilderError;
    /// This is usually the final step in the payload building process and is
    /// called when we are ready to convert the interim payload builder state
    /// into a final payload that can be submitted to the sequencer.
    fn try_from(context: PayloadBuilderContext<Client>) -> Result<Self, Self::Error> {
        let mut context = context;
        let payload_id = context.block_ctx.payload_id();
        let senders = context.senders()?;
        let evm_env = context.block_ctx.evm_env()?;
        let state = context.evm.db_mut();
        state.merge_transitions(BundleRetention::Reverts);

        let block_number = context.block_ctx.parent().number.saturating_add(1);
        let transactions_root = proofs::calculate_transaction_root(&context.transactions);
        let chain_spec = context.block_ctx.chain_spec();
        let timestamp = context.block_ctx.attributes().timestamp;

        let execution_outcome = ExecutionOutcome::new(
            state.take_bundle(),
            vec![context.receipts],
            block_number,
            Vec::new(),
        );
        let receipts_root = execution_outcome
            .generic_receipts_root_slow(block_number, |receipts| {
                calculate_receipt_root_no_memo_optimism(receipts, chain_spec, timestamp)
            })
            .expect("number is in range");

        let logs_bloom = execution_outcome
            .block_logs_bloom(block_number)
            .expect("number is in range");

        let hashed_state = state
            .database
            .as_ref()
            .hashed_post_state(execution_outcome.state());

        let (state_root, trie_output) = {
            state
                .database
                .as_ref()
                .state_root_with_updates(hashed_state.clone())
                .inspect_err(|err| {
                    warn!(target: "payload_builder",
                    parent_header=%context.block_ctx.parent().hash(),
                        %err,
                        "failed to calculate state root for payload"
                    );
                })?
        };

        // withdrawals root field in block header is used for storage root of L2 predeploy
        // `l2tol1-message-passer`
        let (withdrawals_root, requests_hash) = if context.block_ctx.is_isthmus_active() {
            (
                Some(
                    isthmus::withdrawals_root(execution_outcome.state(), state.database.as_ref())
                        .map_err(PayloadBuilderError::other)?,
                ),
                Some(EMPTY_REQUESTS_HASH),
            )
        } else if context.block_ctx.is_canyon_active() {
            (Some(EMPTY_WITHDRAWALS), None)
        } else {
            (None, None)
        };

        // OP doesn't support blobs/EIP-4844.
        // https://specs.optimism.io/protocol/exec-engine.html#ecotone-disable-blob-transactions
        // Need [Some] or [None] based on hardfork to match block hash.
        let (excess_blob_gas, blob_gas_used) = if context.block_ctx.is_ecotone_active() {
            (Some(0), Some(0))
        } else {
            (None, None)
        };

        let extra_data = context.block_ctx.holocene_extra_data()?;

        let header = Header {
            parent_hash: context.block_ctx.parent().hash(),
            ommers_hash: EMPTY_OMMER_ROOT_HASH,
            beneficiary: evm_env.block_env.beneficiary,
            state_root,
            transactions_root,
            receipts_root,
            withdrawals_root,
            logs_bloom,
            timestamp,
            mix_hash: context.block_ctx.attributes().prev_randao,
            nonce: BEACON_NONCE.into(),
            base_fee_per_gas: Some(evm_env.block_env.basefee),
            number: block_number,
            gas_limit: evm_env.block_env.gas_limit,
            difficulty: U256::ZERO,
            gas_used: context.gas_used,
            extra_data,
            parent_beacon_block_root: context.block_ctx.attributes().parent_beacon_block_root,
            blob_gas_used,
            excess_blob_gas,
            requests_hash,
        };

        // seal the block
        let block = Block::<OpTransactionSigned>::new(
            header,
            BlockBody {
                transactions: context.transactions,
                ommers: vec![],
                withdrawals: context.block_ctx.withdrawals().cloned(),
            },
        );

        let sealed_block = Arc::new(block.seal_slow());

        let executed: ExecutedBlockWithTrieUpdates<OpPrimitives> = ExecutedBlockWithTrieUpdates {
            block: ExecutedBlock {
                recovered_block: Arc::new(RecoveredBlock::<
                    alloy_consensus::Block<OpTransactionSigned>,
                >::new_sealed(
                    sealed_block.as_ref().clone(), senders
                )),
                execution_output: Arc::new(execution_outcome),
                hashed_state: Arc::new(hashed_state),
            },
            trie: Arc::new(trie_output),
        };

        Ok(OpBuiltPayload::new(
            payload_id,
            sealed_block,
            context.total_fees,
            Some(executed),
        ))
    }
}
