//! Block Payload Building Context
//!
//! Types in this module are responsible for building one single version of a payload
//! at a time with a known parent block hash and access to the state of the chain.

use super::block::{BlockContext, EvmInstance, PayloadState};
use crate::traits::ClientBounds;
use alloy_consensus::{Eip658Value, Receipt};
use alloy_eips::Typed2718;
use alloy_op_evm::block::receipt_builder::OpReceiptBuilder;
use alloy_primitives::{Address, U256};
use op_alloy_consensus::{OpDepositReceipt, OpTxEnvelope};
use op_revm::OpHaltReason;
use reth_evm::{eth::receipt_builder::ReceiptBuilderCtx, ConfigureEvm, Evm};
use reth_node_api::PayloadBuilderError;
use reth_optimism_node::OpBuiltPayload;
use reth_optimism_payload_builder::error::OpPayloadBuilderError;
use reth_optimism_primitives::{OpReceipt, OpTransactionSigned};
use reth_primitives::Recovered;
use reth_primitives_traits::{SignedTransaction, SignerRecoverable};
use revm::{
    context::{result::ResultAndState, ContextTr},
    DatabaseCommit,
};
use std::sync::Arc;

/// An instance of this type is instantiated when building a new block payload version.
/// There may be multiple instances of this type created for one parent block. Each instance
/// represents a different payload building attempt.
///
/// An instance of this type comes with a preconfigured EVM and State mounted at the
/// parent block hash.
pub struct PayloadBuilderContext<Client: ClientBounds> {
    /// Access to the block context that is common to all payloads built on top of the same parent block.
    block_ctx: Arc<BlockContext<Client>>,

    /// Transactions that are included in the payload being built.
    transactions: Vec<OpTransactionSigned>,

    /// Transaction receipts that are generated by the transactions included in the payload.
    receipts: Vec<OpReceipt>,

    /// An EVM instance that is preconfigured with the parent block state and ready to execute
    /// transactions in the context of the payload being built.
    evm: EvmInstance,

    /// Tracks total fees accumulated by the transactions included in the payload.
    total_fees: U256,

    /// The total gas used by the transactions included in the payload.
    gas_used: u64,

    /// The total data availability size used by the transactions included in the payload.
    da_bytes_used: u64,
}

impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// Creates a new payload builder with its state initialized and ready to add user
    /// transactions to it. As part of the initialization all sequencer mandated transactions
    /// are executed and their state changes are applied.
    pub fn new(block_ctx: Arc<BlockContext<Client>>) -> Result<Self, PayloadBuilderError> {
        let evm = block_ctx.create_evm()?;
        let mut instance = Self {
            evm,
            block_ctx,
            transactions: vec![],
            receipts: vec![],
            total_fees: Default::default(),
            gas_used: Default::default(),
            da_bytes_used: Default::default(),
        };

        // Get the mandatory seequencer transactions from the Payload Attributes
        // sent by the CL during FCU.
        let sequencer_txs: Vec<_> = instance
            .block_ctx
            .sequencer_transactions()
            .cloned()
            .collect();

        for tx in sequencer_txs {
            // in include all mandatory sequencer transactions at the top of the payload.
            instance.insert_transaction(tx.value().try_clone_into_recovered().map_err(
                |_| PayloadBuilderError::other(OpPayloadBuilderError::TransactionEcRecoverFailed),
            )?)?;
        }

        Ok(instance)
    }
}

// Transaction simulation and inclusion methods for the payload builder context.
impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// Simulates a transaction in the context of the currently aggregated state of the
    /// this payload without committing it.
    ///
    /// This can be used to implement various filters and checks such as revert protection,
    /// builder payments, gas usage, etc.
    pub fn simulate_transaction(
        &mut self,
        transaction: &Recovered<OpTxEnvelope>,
    ) -> Result<ResultAndState<OpHaltReason>, PayloadBuilderError> {
        // A sequencer's block should never contain blob transactions.
        if transaction.is_eip4844() {
            return Err(PayloadBuilderError::other(
                OpPayloadBuilderError::BlobTransactionRejected,
            ));
        }

        self.evm
            .transact(transaction)
            .map_err(PayloadBuilderError::other)
    }

    /// Adds a transaction to the payload being built and commits to its state.
    /// Any state changes caused by this transaction will affect the next simulated or
    /// included transaction.
    pub fn insert_transaction(
        &mut self,
        transaction: Recovered<OpTxEnvelope>,
    ) -> Result<(), PayloadBuilderError> {
        // Run the transaction
        let ResultAndState { result, state } = self.simulate_transaction(&transaction)?;

        // accumulate used gas and fees regardless of the result
        self.gas_used += result.gas_used();

        // build a receipt for the transaction
        let receipt_builder = self
            .block_ctx
            .evm_config()
            .block_executor_factory()
            .receipt_builder();

        let receipt = match receipt_builder.build_receipt(ReceiptBuilderCtx {
            tx: transaction.inner(),
            evm: &self.evm,
            result,
            state: &state,
            cumulative_gas_used: self.gas_used,
        }) {
            // this path is taken when the transaction is a regular transaction
            Ok(receipt) => receipt,

            // this path is taken when the transaction is a deposit
            Err(receipt_ctx) => {
                let receipt = Receipt {
                    status: Eip658Value::Eip658(receipt_ctx.result.is_success()),
                    cumulative_gas_used: receipt_ctx.cumulative_gas_used,
                    logs: receipt_ctx.result.into_logs(),
                };

                // stop holding a ref on the EVM
                // w're going to ref it mutably in a bit
                let _ = receipt_ctx.evm;

                let deposit_nonce = if self.block_ctx().is_regolith_active() {
                    Some(
                        self.evm
                            .db()
                            .load_cache_account(transaction.signer())
                            .map(|account| account.account_info().unwrap_or_default().nonce)
                            .map_err(|_| {
                                PayloadBuilderError::other(
                                    OpPayloadBuilderError::AccountLoadFailed(transaction.signer()),
                                )
                            })?,
                    )
                } else {
                    // Note that this *only* needs to be done post-regolith hardfork, as deposit nonces
                    // were not introduced in Bedrock.
                    None
                };
                receipt_builder.build_deposit_receipt(OpDepositReceipt {
                    inner: receipt,
                    deposit_nonce,
                    // The deposit receipt version was introduced in Canyon to indicate an
                    // update to how receipt hashes should be computed when set.
                    // The state transition process ensures this is only set for post-Canyon
                    // deposit transactions.
                    deposit_receipt_version: self.block_ctx().is_canyon_active().then_some(1),
                })
            }
        };

        self.receipts.push(receipt);

        // store state changes of this transaction
        self.state().commit(state);

        // add the transaction to the list of transactions included in the payload
        self.transactions.push(transaction.into_inner());

        // we're done. At this point the state of the payload has been updated
        // to reflect the execution of the transaction.
        Ok(())
    }
}

// private methods for the payload builder context.
impl<Client: ClientBounds> PayloadBuilderContext<Client> {
    /// the context of the block that this payload is being built on top of.
    fn block_ctx(&self) -> &BlockContext<Client> {
        &self.block_ctx
    }

    /// Returns the list of all transaction senders (signers) that are included in the
    /// payload being built in the same order as the transactions themselves.
    fn senders(&self) -> Result<Vec<Address>, PayloadBuilderError> {
        self.transactions
            .iter()
            .map(|tx| tx.recover_signer())
            .collect::<Result<Vec<_>, _>>()
            .map_err(PayloadBuilderError::other)
    }

    /// Returns the state of the evm that is used to build the payload.
    /// This state accumulates all changes made by transactions included in the payload.
    fn state(&mut self) -> &mut PayloadState {
        self.evm.db_mut()
    }
}

impl<Client: ClientBounds> TryFrom<PayloadBuilderContext<Client>> for OpBuiltPayload {
    type Error = PayloadBuilderError;
    /// This is usually the final step in the payload building process and is
    /// called when we are ready to convert the interim payload builder state
    /// into a final payload that can be submitted to the chain.
    fn try_from(_context: PayloadBuilderContext<Client>) -> Result<Self, Self::Error> {
        todo!()
    }
}
